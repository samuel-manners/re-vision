{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { use } from \"./use.js\";\nimport { useInstantSearchContext } from \"./useInstantSearchContext.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nimport { useRSCContext } from \"./useRSCContext.js\";\nexport function useWidget(_ref) {\n  var _waitingForResultsRef;\n  var widget = _ref.widget,\n    parentIndex = _ref.parentIndex,\n    props = _ref.props,\n    shouldSsr = _ref.shouldSsr;\n  var waitingForResultsRef = useRSCContext();\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget);\n  var search = useInstantSearchContext();\n\n  // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    // Scenario 1: the widget is added for the first time.\n    if (!cleanupTimerRef.current) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current);\n\n      // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n      var arePropsEqual = dequal(props, prevPropsRef.current);\n\n      // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n      if (!arePropsEqual) {\n        parentIndex.removeWidgets([previousWidget]);\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(function () {\n        search._schedule(function () {\n          if (search._preventWidgetCleanup) return;\n          parentIndex.removeWidgets([previousWidget]);\n        });\n      });\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly, search, props]);\n  if (shouldAddWidgetEarly || (waitingForResultsRef === null || waitingForResultsRef === void 0 ? void 0 : (_waitingForResultsRef = waitingForResultsRef.current) === null || _waitingForResultsRef === void 0 ? void 0 : _waitingForResultsRef.status) === 'pending') {\n    parentIndex.addWidgets([widget]);\n  }\n  if (typeof window === 'undefined' && waitingForResultsRef !== null && waitingForResultsRef !== void 0 && waitingForResultsRef.current &&\n  // We need the widgets contained in the index to be added before we trigger the search request.\n  widget.$$type !== 'ais.index') {\n    var _search$helper;\n    use(waitingForResultsRef.current);\n    // If we made a second request because of DynamicWidgets, we need to wait for the second result,\n    // except for DynamicWidgets itself which needs to render its children after the first result.\n    if (widget.$$type !== 'ais.dynamicWidgets' && (_search$helper = search.helper) !== null && _search$helper !== void 0 && _search$helper.lastResults) {\n      use(waitingForResultsRef.current);\n    }\n  }\n}","map":{"version":3,"names":["useEffect","useRef","dequal","use","useInstantSearchContext","useIsomorphicLayoutEffect","useRSCContext","useWidget","_ref","_waitingForResultsRef","widget","parentIndex","props","shouldSsr","waitingForResultsRef","prevPropsRef","current","prevWidgetRef","cleanupTimerRef","shouldAddWidgetEarly","getWidgets","includes","search","previousWidget","addWidgets","clearTimeout","arePropsEqual","removeWidgets","setTimeout","_schedule","_preventWidgetCleanup","status","window","$$type","_search$helper","helper","lastResults"],"sources":["C:/Users/Samue/OneDrive/Documents/University/Year 3/Computing Project/Code/RevisionWebApp/re-vision/node_modules/react-instantsearch-core/dist/es/lib/useWidget.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { use } from \"./use.js\";\nimport { useInstantSearchContext } from \"./useInstantSearchContext.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nimport { useRSCContext } from \"./useRSCContext.js\";\nexport function useWidget(_ref) {\n  var _waitingForResultsRef;\n  var widget = _ref.widget,\n    parentIndex = _ref.parentIndex,\n    props = _ref.props,\n    shouldSsr = _ref.shouldSsr;\n  var waitingForResultsRef = useRSCContext();\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget);\n  var search = useInstantSearchContext();\n\n  // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    // Scenario 1: the widget is added for the first time.\n    if (!cleanupTimerRef.current) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current);\n\n      // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n      var arePropsEqual = dequal(props, prevPropsRef.current);\n\n      // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n      if (!arePropsEqual) {\n        parentIndex.removeWidgets([previousWidget]);\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(function () {\n        search._schedule(function () {\n          if (search._preventWidgetCleanup) return;\n          parentIndex.removeWidgets([previousWidget]);\n        });\n      });\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly, search, props]);\n  if (shouldAddWidgetEarly || (waitingForResultsRef === null || waitingForResultsRef === void 0 ? void 0 : (_waitingForResultsRef = waitingForResultsRef.current) === null || _waitingForResultsRef === void 0 ? void 0 : _waitingForResultsRef.status) === 'pending') {\n    parentIndex.addWidgets([widget]);\n  }\n  if (typeof window === 'undefined' && waitingForResultsRef !== null && waitingForResultsRef !== void 0 && waitingForResultsRef.current &&\n  // We need the widgets contained in the index to be added before we trigger the search request.\n  widget.$$type !== 'ais.index') {\n    var _search$helper;\n    use(waitingForResultsRef.current);\n    // If we made a second request because of DynamicWidgets, we need to wait for the second result,\n    // except for DynamicWidgets itself which needs to render its children after the first result.\n    if (widget.$$type !== 'ais.dynamicWidgets' && (_search$helper = search.helper) !== null && _search$helper !== void 0 && _search$helper.lastResults) {\n      use(waitingForResultsRef.current);\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}