{"ast":null,"code":"import { CameraRuntimeError } from '../CameraError';\nfunction filtersToFilterMap(filters) {\n  return filters.reduce((map, curr, index) => {\n    for (const key in curr) {\n      // @ts-expect-error keys are untyped\n      map[key] = {\n        // @ts-expect-error keys are untyped\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        target: curr[key],\n        priority: filters.length - index\n      };\n    }\n    return map;\n  }, {});\n}\n\n/**\n * Get the best matching Camera format for the given device that satisfies your requirements using a sorting filter. By default, formats are sorted by highest to lowest resolution.\n *\n * The {@linkcode filters | filters} are ranked by priority, from highest to lowest.\n * This means the first item you pass will have a higher priority than the second, and so on.\n *\n * @param device The Camera Device you're currently using\n * @param filter The filter you want to use. The format that matches your filter the closest will be returned\n * @returns The format that matches your filter the closest.\n *\n * @example\n * ```ts\n * const format = getCameraFormat(device, [\n *   { videoResolution: { width: 3048, height: 2160 } },\n *   { fps: 60 }\n * ])\n * ```\n */\nexport function getCameraFormat(device, filters) {\n  // Combine filters into a single filter map for constant-time lookup\n  const filter = filtersToFilterMap(filters);\n  let bestFormat = device.formats[0];\n  if (bestFormat == null) throw new CameraRuntimeError('device/invalid-device', `The given Camera Device (${device.id}) does not have any formats!`);\n\n  // Compare each format using a point scoring system\n  for (const format of device.formats) {\n    let leftPoints = 0;\n    let rightPoints = 0;\n\n    // Video Resolution\n    if (filter.videoResolution != null) {\n      const leftVideoResolution = bestFormat.videoWidth * bestFormat.videoHeight;\n      const rightVideoResolution = format.videoWidth * format.videoHeight;\n      if (filter.videoResolution.target === 'max') {\n        // We just want the maximum resolution\n        if (leftVideoResolution > rightVideoResolution) leftPoints += filter.videoResolution.priority;\n        if (rightVideoResolution > leftVideoResolution) rightPoints += filter.videoResolution.priority;\n      } else {\n        // Find video resolution closest to the filter (ignoring orientation)\n        const targetResolution = filter.videoResolution.target.width * filter.videoResolution.target.height;\n        const leftDiff = Math.abs(leftVideoResolution - targetResolution);\n        const rightDiff = Math.abs(rightVideoResolution - targetResolution);\n        if (leftDiff < rightDiff) leftPoints += filter.videoResolution.priority;\n        if (rightDiff < leftDiff) rightPoints += filter.videoResolution.priority;\n      }\n    }\n\n    // Photo Resolution\n    if (filter.photoResolution != null) {\n      const leftPhotoResolution = bestFormat.photoWidth * bestFormat.photoHeight;\n      const rightPhotoResolution = format.photoWidth * format.photoHeight;\n      if (filter.photoResolution.target === 'max') {\n        // We just want the maximum resolution\n        if (leftPhotoResolution > rightPhotoResolution) leftPoints += filter.photoResolution.priority;\n        if (rightPhotoResolution > leftPhotoResolution) rightPoints += filter.photoResolution.priority;\n      } else {\n        // Find closest photo resolution to the filter (ignoring orientation)\n        const targetResolution = filter.photoResolution.target.width * filter.photoResolution.target.height;\n        const leftDiff = Math.abs(leftPhotoResolution - targetResolution);\n        const rightDiff = Math.abs(rightPhotoResolution - targetResolution);\n        if (leftDiff < rightDiff) leftPoints += filter.photoResolution.priority;\n        if (rightDiff < leftDiff) rightPoints += filter.photoResolution.priority;\n      }\n    }\n\n    // Find closest aspect ratio (video)\n    if (filter.videoAspectRatio != null) {\n      const leftAspect = bestFormat.videoWidth / bestFormat.videoHeight;\n      const rightAspect = format.videoWidth / format.videoHeight;\n      const leftDiff = Math.abs(leftAspect - filter.videoAspectRatio.target);\n      const rightDiff = Math.abs(rightAspect - filter.videoAspectRatio.target);\n      if (leftDiff < rightDiff) leftPoints += filter.videoAspectRatio.priority;\n      if (rightDiff < leftDiff) rightPoints += filter.videoAspectRatio.priority;\n    }\n\n    // Find closest aspect ratio (photo)\n    if (filter.photoAspectRatio != null) {\n      const leftAspect = bestFormat.photoWidth / bestFormat.photoHeight;\n      const rightAspect = format.photoWidth / format.photoHeight;\n      const leftDiff = Math.abs(leftAspect - filter.photoAspectRatio.target);\n      const rightDiff = Math.abs(rightAspect - filter.photoAspectRatio.target);\n      if (leftDiff < rightDiff) leftPoints += filter.photoAspectRatio.priority;\n      if (rightDiff < leftDiff) rightPoints += filter.photoAspectRatio.priority;\n    }\n\n    // Find closest max FPS\n    if (filter.fps != null) {\n      if (filter.fps.target === 'max') {\n        if (bestFormat.maxFps > format.maxFps) leftPoints += filter.fps.priority;\n        if (format.maxFps > bestFormat.maxFps) rightPoints += filter.fps.priority;\n      } else {\n        if (bestFormat.maxFps >= filter.fps.target) leftPoints += filter.fps.priority;\n        if (format.maxFps >= filter.fps.target) rightPoints += filter.fps.priority;\n      }\n    }\n\n    // Find closest ISO\n    if (filter.iso != null) {\n      if (filter.iso.target === 'max') {\n        if (bestFormat.maxISO > format.maxISO) leftPoints += filter.iso.priority;\n        if (format.maxISO > bestFormat.maxISO) rightPoints += filter.iso.priority;\n      } else if (filter.iso.target === 'min') {\n        if (bestFormat.minISO < format.minISO) leftPoints += filter.iso.priority;\n        if (format.minISO < bestFormat.minISO) rightPoints += filter.iso.priority;\n      } else {\n        if (filter.iso.target >= bestFormat.minISO && filter.iso.target <= bestFormat.maxISO) leftPoints += filter.iso.priority;\n        if (filter.iso.target >= format.minISO && filter.iso.target <= format.maxISO) rightPoints += filter.iso.priority;\n      }\n    }\n\n    // Find video stabilization mode\n    if (filter.videoStabilizationMode != null) {\n      if (bestFormat.videoStabilizationModes.includes(filter.videoStabilizationMode.target)) leftPoints++;\n      if (format.videoStabilizationModes.includes(filter.videoStabilizationMode.target)) rightPoints++;\n    }\n\n    // Find pixel format\n    if (filter.pixelFormat != null) {\n      if (bestFormat.pixelFormats.includes(filter.pixelFormat.target)) leftPoints++;\n      if (format.pixelFormats.includes(filter.pixelFormat.target)) rightPoints++;\n    }\n\n    // Find Photo HDR formats\n    if (filter.photoHdr != null) {\n      if (bestFormat.supportsPhotoHdr === filter.photoHdr.target) leftPoints++;\n      if (format.supportsPhotoHdr === filter.photoHdr.target) rightPoints++;\n    }\n\n    // Find Video HDR formats\n    if (filter.videoHdr != null) {\n      if (bestFormat.supportsVideoHdr === filter.videoHdr.target) leftPoints++;\n      if (format.supportsVideoHdr === filter.videoHdr.target) rightPoints++;\n    }\n    if (rightPoints > leftPoints) bestFormat = format;\n  }\n  return bestFormat;\n}","map":{"version":3,"names":["CameraRuntimeError","filtersToFilterMap","filters","reduce","map","curr","index","key","target","priority","length","getCameraFormat","device","filter","bestFormat","formats","id","format","leftPoints","rightPoints","videoResolution","leftVideoResolution","videoWidth","videoHeight","rightVideoResolution","targetResolution","width","height","leftDiff","Math","abs","rightDiff","photoResolution","leftPhotoResolution","photoWidth","photoHeight","rightPhotoResolution","videoAspectRatio","leftAspect","rightAspect","photoAspectRatio","fps","maxFps","iso","maxISO","minISO","videoStabilizationMode","videoStabilizationModes","includes","pixelFormat","pixelFormats","photoHdr","supportsPhotoHdr","videoHdr","supportsVideoHdr"],"sources":["C:\\Users\\Samue\\OneDrive\\Documents\\University\\Year 3\\Computing Project\\Code\\RevisionWebApp\\re-vision\\node_modules\\react-native-vision-camera\\src\\devices\\getCameraFormat.ts"],"sourcesContent":["import type { CameraDevice, CameraDeviceFormat, VideoStabilizationMode } from '../CameraDevice'\nimport { CameraRuntimeError } from '../CameraError'\nimport { PixelFormat } from '../PixelFormat'\n\ninterface Size {\n  width: number\n  height: number\n}\n\nexport interface FormatFilter {\n  /**\n   * The target resolution of the video (and frame processor) output pipeline.\n   * If no format supports the given resolution, the format closest to this value will be used.\n   */\n  videoResolution?: Size | 'max'\n  /**\n   * The target resolution of the photo output pipeline.\n   * If no format supports the given resolution, the format closest to this value will be used.\n   */\n  photoResolution?: Size | 'max'\n  /**\n   * The target aspect ratio of the video (and preview) output, expressed as a factor: `width / height`.\n   * (Note: Cameras are in landscape orientation)\n   *\n   * In most cases, you want this to be as close to the screen's aspect ratio as possible (usually ~9:16).\n   *\n   * @example\n   * ```ts\n   * const screen = Dimensions.get('screen')\n   * targetVideoAspectRatio: screen.height / screen.width\n   * ```\n   */\n  videoAspectRatio?: number\n  /**\n   * The target aspect ratio of the photo output, expressed as a factor: `width / height`.\n   * (Note: Cameras are in landscape orientation)\n   *\n   * In most cases, you want this to be the same as `targetVideoAspectRatio`, which you often want\n   * to be as close to the screen's aspect ratio as possible (usually ~9:16)\n   *\n   * @example\n   * ```ts\n   * const screen = Dimensions.get('screen')\n   * targetPhotoAspectRatio: screen.height / screen.width\n   * ```\n   */\n  photoAspectRatio?: number\n  /**\n   * The target FPS you want to record video at.\n   * If the FPS requirements can not be met, the format closest to this value will be used.\n   */\n  fps?: number | 'max'\n  /**\n   * The target video stabilization mode you want to use.\n   * If no format supports the target video stabilization mode, the best other matching format will be used.\n   */\n  videoStabilizationMode?: VideoStabilizationMode\n  /**\n   * The target pixel format you want to use.\n   * If no format supports the target pixel format, the best other matching format will be used.\n   */\n  pixelFormat?: PixelFormat\n  /**\n   * Whether you want to find a format that supports Photo HDR.\n   */\n  photoHdr?: boolean\n  /**\n   * Whether you want to find a format that supports Photo HDR.\n   */\n  videoHdr?: boolean\n  /**\n   * The target ISO value for capturing photos.\n   * Higher ISO values tend to capture sharper photos, at the cost of reduced capture speed.\n   * Lower ISO values tend to capture photos quicker.\n   */\n  iso?: number | 'max' | 'min'\n}\n\ntype FilterWithPriority<T> = {\n  target: Exclude<T, null | undefined>\n  priority: number\n}\ntype FilterMap = {\n  [K in keyof FormatFilter]: FilterWithPriority<FormatFilter[K]>\n}\nfunction filtersToFilterMap(filters: FormatFilter[]): FilterMap {\n  return filters.reduce<FilterMap>((map, curr, index) => {\n    for (const key in curr) {\n      // @ts-expect-error keys are untyped\n      map[key] = {\n        // @ts-expect-error keys are untyped\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        target: curr[key],\n        priority: filters.length - index,\n      }\n    }\n    return map\n  }, {})\n}\n\n/**\n * Get the best matching Camera format for the given device that satisfies your requirements using a sorting filter. By default, formats are sorted by highest to lowest resolution.\n *\n * The {@linkcode filters | filters} are ranked by priority, from highest to lowest.\n * This means the first item you pass will have a higher priority than the second, and so on.\n *\n * @param device The Camera Device you're currently using\n * @param filter The filter you want to use. The format that matches your filter the closest will be returned\n * @returns The format that matches your filter the closest.\n *\n * @example\n * ```ts\n * const format = getCameraFormat(device, [\n *   { videoResolution: { width: 3048, height: 2160 } },\n *   { fps: 60 }\n * ])\n * ```\n */\nexport function getCameraFormat(device: CameraDevice, filters: FormatFilter[]): CameraDeviceFormat {\n  // Combine filters into a single filter map for constant-time lookup\n  const filter = filtersToFilterMap(filters)\n\n  let bestFormat = device.formats[0]\n  if (bestFormat == null)\n    throw new CameraRuntimeError('device/invalid-device', `The given Camera Device (${device.id}) does not have any formats!`)\n\n  // Compare each format using a point scoring system\n  for (const format of device.formats) {\n    let leftPoints = 0\n    let rightPoints = 0\n\n    // Video Resolution\n    if (filter.videoResolution != null) {\n      const leftVideoResolution = bestFormat.videoWidth * bestFormat.videoHeight\n      const rightVideoResolution = format.videoWidth * format.videoHeight\n      if (filter.videoResolution.target === 'max') {\n        // We just want the maximum resolution\n        if (leftVideoResolution > rightVideoResolution) leftPoints += filter.videoResolution.priority\n        if (rightVideoResolution > leftVideoResolution) rightPoints += filter.videoResolution.priority\n      } else {\n        // Find video resolution closest to the filter (ignoring orientation)\n        const targetResolution = filter.videoResolution.target.width * filter.videoResolution.target.height\n        const leftDiff = Math.abs(leftVideoResolution - targetResolution)\n        const rightDiff = Math.abs(rightVideoResolution - targetResolution)\n        if (leftDiff < rightDiff) leftPoints += filter.videoResolution.priority\n        if (rightDiff < leftDiff) rightPoints += filter.videoResolution.priority\n      }\n    }\n\n    // Photo Resolution\n    if (filter.photoResolution != null) {\n      const leftPhotoResolution = bestFormat.photoWidth * bestFormat.photoHeight\n      const rightPhotoResolution = format.photoWidth * format.photoHeight\n      if (filter.photoResolution.target === 'max') {\n        // We just want the maximum resolution\n        if (leftPhotoResolution > rightPhotoResolution) leftPoints += filter.photoResolution.priority\n        if (rightPhotoResolution > leftPhotoResolution) rightPoints += filter.photoResolution.priority\n      } else {\n        // Find closest photo resolution to the filter (ignoring orientation)\n        const targetResolution = filter.photoResolution.target.width * filter.photoResolution.target.height\n        const leftDiff = Math.abs(leftPhotoResolution - targetResolution)\n        const rightDiff = Math.abs(rightPhotoResolution - targetResolution)\n        if (leftDiff < rightDiff) leftPoints += filter.photoResolution.priority\n        if (rightDiff < leftDiff) rightPoints += filter.photoResolution.priority\n      }\n    }\n\n    // Find closest aspect ratio (video)\n    if (filter.videoAspectRatio != null) {\n      const leftAspect = bestFormat.videoWidth / bestFormat.videoHeight\n      const rightAspect = format.videoWidth / format.videoHeight\n      const leftDiff = Math.abs(leftAspect - filter.videoAspectRatio.target)\n      const rightDiff = Math.abs(rightAspect - filter.videoAspectRatio.target)\n      if (leftDiff < rightDiff) leftPoints += filter.videoAspectRatio.priority\n      if (rightDiff < leftDiff) rightPoints += filter.videoAspectRatio.priority\n    }\n\n    // Find closest aspect ratio (photo)\n    if (filter.photoAspectRatio != null) {\n      const leftAspect = bestFormat.photoWidth / bestFormat.photoHeight\n      const rightAspect = format.photoWidth / format.photoHeight\n      const leftDiff = Math.abs(leftAspect - filter.photoAspectRatio.target)\n      const rightDiff = Math.abs(rightAspect - filter.photoAspectRatio.target)\n      if (leftDiff < rightDiff) leftPoints += filter.photoAspectRatio.priority\n      if (rightDiff < leftDiff) rightPoints += filter.photoAspectRatio.priority\n    }\n\n    // Find closest max FPS\n    if (filter.fps != null) {\n      if (filter.fps.target === 'max') {\n        if (bestFormat.maxFps > format.maxFps) leftPoints += filter.fps.priority\n        if (format.maxFps > bestFormat.maxFps) rightPoints += filter.fps.priority\n      } else {\n        if (bestFormat.maxFps >= filter.fps.target) leftPoints += filter.fps.priority\n        if (format.maxFps >= filter.fps.target) rightPoints += filter.fps.priority\n      }\n    }\n\n    // Find closest ISO\n    if (filter.iso != null) {\n      if (filter.iso.target === 'max') {\n        if (bestFormat.maxISO > format.maxISO) leftPoints += filter.iso.priority\n        if (format.maxISO > bestFormat.maxISO) rightPoints += filter.iso.priority\n      } else if (filter.iso.target === 'min') {\n        if (bestFormat.minISO < format.minISO) leftPoints += filter.iso.priority\n        if (format.minISO < bestFormat.minISO) rightPoints += filter.iso.priority\n      } else {\n        if (filter.iso.target >= bestFormat.minISO && filter.iso.target <= bestFormat.maxISO) leftPoints += filter.iso.priority\n        if (filter.iso.target >= format.minISO && filter.iso.target <= format.maxISO) rightPoints += filter.iso.priority\n      }\n    }\n\n    // Find video stabilization mode\n    if (filter.videoStabilizationMode != null) {\n      if (bestFormat.videoStabilizationModes.includes(filter.videoStabilizationMode.target)) leftPoints++\n      if (format.videoStabilizationModes.includes(filter.videoStabilizationMode.target)) rightPoints++\n    }\n\n    // Find pixel format\n    if (filter.pixelFormat != null) {\n      if (bestFormat.pixelFormats.includes(filter.pixelFormat.target)) leftPoints++\n      if (format.pixelFormats.includes(filter.pixelFormat.target)) rightPoints++\n    }\n\n    // Find Photo HDR formats\n    if (filter.photoHdr != null) {\n      if (bestFormat.supportsPhotoHdr === filter.photoHdr.target) leftPoints++\n      if (format.supportsPhotoHdr === filter.photoHdr.target) rightPoints++\n    }\n\n    // Find Video HDR formats\n    if (filter.videoHdr != null) {\n      if (bestFormat.supportsVideoHdr === filter.videoHdr.target) leftPoints++\n      if (format.supportsVideoHdr === filter.videoHdr.target) rightPoints++\n    }\n\n    if (rightPoints > leftPoints) bestFormat = format\n  }\n\n  return bestFormat\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}