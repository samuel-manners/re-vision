{"ast":null,"code":"'use strict';\n\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\nvar defaultsPure = require('../functions/defaultsPure');\nvar objectHasKeys = require('../functions/objectHasKeys');\nvar omit = require('../functions/omit');\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n    var valueAsString = '' + value;\n    var facetRefinement = !refinementList[attribute] ? [valueAsString] : refinementList[attribute].concat(valueAsString);\n    var mod = {};\n    mod[attribute] = facetRefinement;\n    return defaultsPure({}, mod, refinementList);\n  },\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function (v, f) {\n        return attribute === f;\n      });\n    }\n    var valueAsString = '' + value;\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (value === undefined) throw new Error('toggleRefinement should be used with a value');\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (attribute === undefined) {\n      // return the same object if the list is already empty\n      // this is mainly for tests, as it doesn't have much impact on performance\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n      var newRefinementList = Object.keys(refinementList).reduce(function (memo, key) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function (value) {\n          return !attribute(value, key, refinementType);\n        });\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n        memo[key] = facetList;\n        return memo;\n      }, {});\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n\n    // We return nothing if the attribute is not undefined, a string or a function,\n    // as it is not a valid value for a refinement\n    return undefined;\n  },\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean} true if the attribute is refined, false otherwise\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements = Boolean(refinementList[attribute]) && refinementList[attribute].length > 0;\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n    var refinementValueAsString = '' + refinementValue;\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  }\n};\nmodule.exports = lib;","map":{"version":3,"names":["defaultsPure","require","objectHasKeys","omit","lib","addRefinement","refinementList","attribute","value","isRefined","valueAsString","facetRefinement","concat","mod","removeRefinement","undefined","clearRefinement","v","f","toggleRefinement","Error","refinementType","hasChanged","newRefinementList","Object","keys","reduce","memo","key","values","facetList","filter","length","refinementValue","containsRefinements","Boolean","refinementValueAsString","indexOf","module","exports"],"sources":["C:/Users/Samue/OneDrive/Documents/University/Year 3/Computing Project/Code/RevisionWebApp/re-vision/node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js"],"sourcesContent":["'use strict';\n\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar defaultsPure = require('../functions/defaultsPure');\nvar objectHasKeys = require('../functions/objectHasKeys');\nvar omit = require('../functions/omit');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n\n    var facetRefinement = !refinementList[attribute]\n      ? [valueAsString]\n      : refinementList[attribute].concat(valueAsString);\n\n    var mod = {};\n\n    mod[attribute] = facetRefinement;\n\n    return defaultsPure({}, mod, refinementList);\n  },\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(\n    refinementList,\n    attribute,\n    value\n  ) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function (v, f) {\n        return attribute === f;\n      });\n    }\n\n    var valueAsString = '' + value;\n\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(\n    refinementList,\n    attribute,\n    value\n  ) {\n    if (value === undefined)\n      throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(\n    refinementList,\n    attribute,\n    refinementType\n  ) {\n    if (attribute === undefined) {\n      // return the same object if the list is already empty\n      // this is mainly for tests, as it doesn't have much impact on performance\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n\n      var newRefinementList = Object.keys(refinementList).reduce(function (\n        memo,\n        key\n      ) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function (value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n\n        memo[key] = facetList;\n\n        return memo;\n      },\n      {});\n\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n\n    // We return nothing if the attribute is not undefined, a string or a function,\n    // as it is not a valid value for a refinement\n    return undefined;\n  },\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean} true if the attribute is refined, false otherwise\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements =\n      Boolean(refinementList[attribute]) &&\n      refinementList[attribute].length > 0;\n\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  },\n};\n\nmodule.exports = lib;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}