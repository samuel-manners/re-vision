{"ast":null,"code":"import { useEffect, useState } from 'react';\nimport { sortDevices } from '../utils/FormatFilter';\nimport { Camera } from '../Camera';\nimport { parsePhysicalDeviceTypes } from '../CameraDevice';\nconst DefaultCameraDevices = {\n  back: undefined,\n  external: undefined,\n  front: undefined,\n  unspecified: undefined\n};\n\n/**\n * Gets the best available {@linkcode CameraDevice}. Devices with more cameras are preferred.\n *\n * @returns The best matching {@linkcode CameraDevice}.\n * @throws {@linkcode CameraRuntimeError} if no device was found.\n * @example\n * ```tsx\n * const device = useCameraDevice()\n * // ...\n * return <Camera device={device} />\n * ```\n */\n\n/**\n * Gets a {@linkcode CameraDevice} for the requested device type.\n *\n * @param {PhysicalCameraDeviceType | LogicalCameraDeviceType} deviceType Specifies a device type which will be used as a device filter.\n * @returns A {@linkcode CameraDevice} for the requested device type.\n * @throws {@linkcode CameraRuntimeError} if no device was found.\n * @example\n * ```tsx\n * const device = useCameraDevice('wide-angle-camera')\n * // ...\n * return <Camera device={device} />\n * ```\n */\n\nexport function useCameraDevices(deviceType) {\n  const [cameraDevices, setCameraDevices] = useState(DefaultCameraDevices);\n  useEffect(() => {\n    let isMounted = true;\n    const loadDevice = async () => {\n      let devices = await Camera.getAvailableCameraDevices();\n      if (!isMounted) return;\n      devices = devices.sort(sortDevices);\n      if (deviceType != null) {\n        devices = devices.filter(d => {\n          const parsedType = parsePhysicalDeviceTypes(d.devices);\n          return parsedType === deviceType;\n        });\n      }\n      setCameraDevices({\n        back: devices.find(d => d.position === 'back'),\n        external: devices.find(d => d.position === 'external'),\n        front: devices.find(d => d.position === 'front'),\n        unspecified: devices.find(d => d.position === 'unspecified')\n      });\n    };\n    loadDevice();\n    return () => {\n      isMounted = false;\n    };\n  }, [deviceType]);\n  return cameraDevices;\n}","map":{"version":3,"names":["useEffect","useState","sortDevices","Camera","parsePhysicalDeviceTypes","DefaultCameraDevices","back","undefined","external","front","unspecified","useCameraDevices","deviceType","cameraDevices","setCameraDevices","isMounted","loadDevice","devices","getAvailableCameraDevices","sort","filter","d","parsedType","find","position"],"sources":["C:\\Users\\Samue\\OneDrive\\Documents\\University\\Year 3\\Computing Project\\Code\\RevisionWebApp\\re-vision\\node_modules\\react-native-vision-camera\\src\\hooks\\useCameraDevices.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport type { CameraPosition } from '../CameraPosition';\nimport { sortDevices } from '../utils/FormatFilter';\nimport { Camera } from '../Camera';\nimport { CameraDevice, LogicalCameraDeviceType, parsePhysicalDeviceTypes, PhysicalCameraDeviceType } from '../CameraDevice';\n\nexport type CameraDevices = {\n  [key in CameraPosition]: CameraDevice | undefined;\n};\nconst DefaultCameraDevices: CameraDevices = {\n  back: undefined,\n  external: undefined,\n  front: undefined,\n  unspecified: undefined,\n};\n\n/**\n * Gets the best available {@linkcode CameraDevice}. Devices with more cameras are preferred.\n *\n * @returns The best matching {@linkcode CameraDevice}.\n * @throws {@linkcode CameraRuntimeError} if no device was found.\n * @example\n * ```tsx\n * const device = useCameraDevice()\n * // ...\n * return <Camera device={device} />\n * ```\n */\nexport function useCameraDevices(): CameraDevices;\n\n/**\n * Gets a {@linkcode CameraDevice} for the requested device type.\n *\n * @param {PhysicalCameraDeviceType | LogicalCameraDeviceType} deviceType Specifies a device type which will be used as a device filter.\n * @returns A {@linkcode CameraDevice} for the requested device type.\n * @throws {@linkcode CameraRuntimeError} if no device was found.\n * @example\n * ```tsx\n * const device = useCameraDevice('wide-angle-camera')\n * // ...\n * return <Camera device={device} />\n * ```\n */\nexport function useCameraDevices(deviceType: PhysicalCameraDeviceType | LogicalCameraDeviceType): CameraDevices;\n\nexport function useCameraDevices(deviceType?: PhysicalCameraDeviceType | LogicalCameraDeviceType): CameraDevices {\n  const [cameraDevices, setCameraDevices] = useState<CameraDevices>(DefaultCameraDevices);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadDevice = async (): Promise<void> => {\n      let devices = await Camera.getAvailableCameraDevices();\n      if (!isMounted) return;\n\n      devices = devices.sort(sortDevices);\n      if (deviceType != null) {\n        devices = devices.filter((d) => {\n          const parsedType = parsePhysicalDeviceTypes(d.devices);\n          return parsedType === deviceType;\n        });\n      }\n      setCameraDevices({\n        back: devices.find((d) => d.position === 'back'),\n        external: devices.find((d) => d.position === 'external'),\n        front: devices.find((d) => d.position === 'front'),\n        unspecified: devices.find((d) => d.position === 'unspecified'),\n      });\n    };\n    loadDevice();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [deviceType]);\n\n  return cameraDevices;\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAE3C,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,MAAM,QAAQ,WAAW;AAClC,SAAgDC,wBAAwB,QAAkC,iBAAiB;AAK3H,MAAMC,oBAAmC,GAAG;EAC1CC,IAAI,EAAEC,SAAS;EACfC,QAAQ,EAAED,SAAS;EACnBE,KAAK,EAAEF,SAAS;EAChBG,WAAW,EAAEH;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,OAAO,SAASI,gBAAgBA,CAACC,UAA+D,EAAiB;EAC/G,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGb,QAAQ,CAAgBI,oBAAoB,CAAC;EAEvFL,SAAS,CAAC,MAAM;IACd,IAAIe,SAAS,GAAG,IAAI;IAEpB,MAAMC,UAAU,GAAG,MAAAA,CAAA,KAA2B;MAC5C,IAAIC,OAAO,GAAG,MAAMd,MAAM,CAACe,yBAAyB,CAAC,CAAC;MACtD,IAAI,CAACH,SAAS,EAAE;MAEhBE,OAAO,GAAGA,OAAO,CAACE,IAAI,CAACjB,WAAW,CAAC;MACnC,IAAIU,UAAU,IAAI,IAAI,EAAE;QACtBK,OAAO,GAAGA,OAAO,CAACG,MAAM,CAAEC,CAAC,IAAK;UAC9B,MAAMC,UAAU,GAAGlB,wBAAwB,CAACiB,CAAC,CAACJ,OAAO,CAAC;UACtD,OAAOK,UAAU,KAAKV,UAAU;QAClC,CAAC,CAAC;MACJ;MACAE,gBAAgB,CAAC;QACfR,IAAI,EAAEW,OAAO,CAACM,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,QAAQ,KAAK,MAAM,CAAC;QAChDhB,QAAQ,EAAES,OAAO,CAACM,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,QAAQ,KAAK,UAAU,CAAC;QACxDf,KAAK,EAAEQ,OAAO,CAACM,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,QAAQ,KAAK,OAAO,CAAC;QAClDd,WAAW,EAAEO,OAAO,CAACM,IAAI,CAAEF,CAAC,IAAKA,CAAC,CAACG,QAAQ,KAAK,aAAa;MAC/D,CAAC,CAAC;IACJ,CAAC;IACDR,UAAU,CAAC,CAAC;IAEZ,OAAO,MAAM;MACXD,SAAS,GAAG,KAAK;IACnB,CAAC;EACH,CAAC,EAAE,CAACH,UAAU,CAAC,CAAC;EAEhB,OAAOC,aAAa;AACtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}