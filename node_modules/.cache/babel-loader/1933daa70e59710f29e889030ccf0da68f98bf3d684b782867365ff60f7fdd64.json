{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport React from 'react';\nimport { requireNativeComponent, findNodeHandle } from 'react-native';\nimport { CameraRuntimeError, tryParseNativeCameraError, isErrorWithCause } from './CameraError';\nimport { CameraModule } from './NativeCameraModule';\nimport { VisionCameraProxy } from './FrameProcessorPlugins';\nimport { CameraDevices } from './CameraDevices';\n\n//#region Types\n\n//#endregion\n\n//#region Camera Component\n/**\n * ### A powerful `<Camera>` component.\n *\n * Read the [VisionCamera documentation](https://react-native-vision-camera.com/) for more information.\n *\n * The `<Camera>` component's most important properties are:\n *\n * * {@linkcode CameraProps.device | device}: Specifies the {@linkcode CameraDevice} to use. Get a {@linkcode CameraDevice} by using the {@linkcode useCameraDevice | useCameraDevice(..)} hook, or manually by using the {@linkcode CameraDevices.getAvailableCameraDevices CameraDevices.getAvailableCameraDevices()} function.\n * * {@linkcode CameraProps.isActive | isActive}: A boolean value that specifies whether the Camera should actively stream video frames or not. This can be compared to a Video component, where `isActive` specifies whether the video is paused or not. If you fully unmount the `<Camera>` component instead of using `isActive={false}`, the Camera will take a bit longer to start again.\n *\n * @example\n * ```tsx\n * function App() {\n *   const device = useCameraDevice('back')\n *\n *   if (device == null) return <NoCameraErrorView />\n *   return (\n *     <Camera\n *       style={StyleSheet.absoluteFill}\n *       device={device}\n *       isActive={true}\n *     />\n *   )\n * }\n * ```\n *\n * @component\n */\nexport class Camera extends React.PureComponent {\n  /** @internal */\n  static displayName = 'Camera';\n  /** @internal */\n  displayName = Camera.displayName;\n  isNativeViewMounted = false;\n  /** @internal */\n  constructor(props) {\n    super(props);\n    this.onViewReady = this.onViewReady.bind(this);\n    this.onInitialized = this.onInitialized.bind(this);\n    this.onStarted = this.onStarted.bind(this);\n    this.onStopped = this.onStopped.bind(this);\n    this.onError = this.onError.bind(this);\n    this.onCodeScanned = this.onCodeScanned.bind(this);\n    this.ref = /*#__PURE__*/React.createRef();\n    this.lastFrameProcessor = undefined;\n    this.state = {\n      isRecordingWithFlash: false\n    };\n  }\n  get handle() {\n    const nodeHandle = findNodeHandle(this.ref.current);\n    if (nodeHandle == null || nodeHandle === -1) {\n      throw new CameraRuntimeError('system/view-not-found', \"Could not get the Camera's native view tag! Does the Camera View exist in the native view-tree?\");\n    }\n    return nodeHandle;\n  }\n\n  //#region View-specific functions (UIViewManager)\n  /**\n   * Take a single photo and write it's content to a temporary file.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while capturing the photo. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * const photo = await camera.current.takePhoto({\n   *   qualityPrioritization: 'quality',\n   *   flash: 'on',\n   *   enableAutoRedEyeReduction: true\n   * })\n   * ```\n   */\n  async takePhoto(options) {\n    try {\n      return await CameraModule.takePhoto(this.handle, options ?? {});\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  getBitRateMultiplier(bitRate) {\n    if (typeof bitRate === 'number' || bitRate == null) return 1;\n    switch (bitRate) {\n      case 'extra-low':\n        return 0.6;\n      case 'low':\n        return 0.8;\n      case 'normal':\n        return 1;\n      case 'high':\n        return 1.2;\n      case 'extra-high':\n        return 1.4;\n    }\n  }\n\n  /**\n   * Start a new video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while starting the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * camera.current.startRecording({\n   *   onRecordingFinished: (video) => console.log(video),\n   *   onRecordingError: (error) => console.error(error),\n   * })\n   * setTimeout(() => {\n   *   camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  startRecording(options) {\n    const {\n      onRecordingError,\n      onRecordingFinished,\n      videoBitRate,\n      ...passThruOptions\n    } = options;\n    if (typeof onRecordingError !== 'function' || typeof onRecordingFinished !== 'function') throw new CameraRuntimeError('parameter/invalid-parameter', 'The onRecordingError or onRecordingFinished functions were not set!');\n    if (options.flash === 'on') {\n      // Enable torch for video recording\n      this.setState({\n        isRecordingWithFlash: true\n      });\n    }\n    const nativeOptions = passThruOptions;\n    if (typeof videoBitRate === 'number') {\n      // If the user passed an absolute number as a bit-rate, we just use this as a full override.\n      nativeOptions.videoBitRateOverride = videoBitRate;\n    } else if (typeof videoBitRate === 'string' && videoBitRate !== 'normal') {\n      // If the user passed 'low'/'normal'/'high', we need to apply this as a multiplier to the native bitrate instead of absolutely setting it\n      nativeOptions.videoBitRateMultiplier = this.getBitRateMultiplier(videoBitRate);\n    }\n    const onRecordCallback = (video, error) => {\n      if (this.state.isRecordingWithFlash) {\n        // disable torch again if it was enabled\n        this.setState({\n          isRecordingWithFlash: false\n        });\n      }\n      if (error != null) return onRecordingError(error);\n      if (video != null) return onRecordingFinished(video);\n    };\n    try {\n      // TODO: Use TurboModules to make this awaitable.\n      CameraModule.startRecording(this.handle, nativeOptions, onRecordCallback);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Pauses the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while pausing the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  async pauseRecording() {\n    try {\n      return await CameraModule.pauseRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Resumes a currently paused video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while resuming the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  async resumeRecording() {\n    try {\n      return await CameraModule.resumeRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Stop the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while stopping the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * await camera.current.startRecording()\n   * setTimeout(async () => {\n   *  const video = await camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  async stopRecording() {\n    try {\n      return await CameraModule.stopRecording(this.handle);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n\n  /**\n   * Focus the camera to a specific point in the coordinate system.\n   * @param {Point} point The point to focus to. This should be relative\n   * to the Camera view's coordinate system and is expressed in points.\n   *  * `(0, 0)` means **top left**.\n   *  * `(CameraView.width, CameraView.height)` means **bottom right**.\n   *\n   * Make sure the value doesn't exceed the CameraView's dimensions.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while focussing. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * await camera.current.focus({\n   *   x: tapEvent.x,\n   *   y: tapEvent.y\n   * })\n   * ```\n   */\n  async focus(point) {\n    try {\n      return await CameraModule.focus(this.handle, point);\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  //#endregion\n\n  //#region Static Functions (NativeModule)\n  /**\n   * Get a list of all available camera devices on the current phone.\n   *\n   * If you use Hooks, use the `useCameraDevices(..)` hook instead.\n   *\n   * * For Camera Devices attached to the phone, it is safe to assume that this will never change.\n   * * For external Camera Devices (USB cameras, Mac continuity cameras, etc.) the available Camera Devices could change over time when the external Camera device gets plugged in or plugged out, so use {@link addCameraDevicesChangedListener | addCameraDevicesChangedListener(...)} to listen for such changes.\n   *\n   * @example\n   * ```ts\n   * const devices = Camera.getAvailableCameraDevices()\n   * const backCameras = devices.filter((d) => d.position === \"back\")\n   * const frontCameras = devices.filter((d) => d.position === \"front\")\n   * ```\n   */\n  static getAvailableCameraDevices() {\n    return CameraDevices.getAvailableCameraDevices();\n  }\n  /**\n   * Adds a listener that gets called everytime the Camera Devices change, for example\n   * when an external Camera Device (USB or continuity Camera) gets plugged in or plugged out.\n   *\n   * If you use Hooks, use the `useCameraDevices()` hook instead.\n   */\n  static addCameraDevicesChangedListener(listener) {\n    return CameraDevices.addCameraDevicesChangedListener(listener);\n  }\n  /**\n   * Gets the current Camera Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the camera.\n   *\n   * To actually prompt the user for camera permission, use {@linkcode Camera.requestCameraPermission | requestCameraPermission()}.\n   */\n  static getCameraPermissionStatus() {\n    return CameraModule.getCameraPermissionStatus();\n  }\n  /**\n   * Gets the current Microphone-Recording Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the microphone.\n   *\n   * To actually prompt the user for microphone permission, use {@linkcode Camera.requestMicrophonePermission | requestMicrophonePermission()}.\n   */\n  static getMicrophonePermissionStatus() {\n    return CameraModule.getMicrophonePermissionStatus();\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new camera permission status.\n   *\n   * If the user has previously blocked the app from using the camera, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  static async requestCameraPermission() {\n    try {\n      return await CameraModule.requestCameraPermission();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new microphone permission status.\n   *\n   * If the user has previously blocked the app from using the microphone, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  static async requestMicrophonePermission() {\n    try {\n      return await CameraModule.requestMicrophonePermission();\n    } catch (e) {\n      throw tryParseNativeCameraError(e);\n    }\n  }\n  //#endregion\n\n  //#region Events (Wrapped to maintain reference equality)\n  onError(event) {\n    const error = event.nativeEvent;\n    const cause = isErrorWithCause(error.cause) ? error.cause : undefined;\n    // @ts-expect-error We're casting from unknown bridge types to TS unions, I expect it to hopefully work\n    const cameraError = new CameraRuntimeError(error.code, error.message, cause);\n    if (this.props.onError != null) {\n      this.props.onError(cameraError);\n    } else {\n      // User didn't pass an `onError` handler, so just log it to console\n      console.error(`Camera.onError(${cameraError.code}): ${cameraError.message}`, cameraError);\n    }\n  }\n  onInitialized() {\n    var _this$props$onInitial, _this$props;\n    (_this$props$onInitial = (_this$props = this.props).onInitialized) === null || _this$props$onInitial === void 0 || _this$props$onInitial.call(_this$props);\n  }\n  onStarted() {\n    var _this$props$onStarted, _this$props2;\n    (_this$props$onStarted = (_this$props2 = this.props).onStarted) === null || _this$props$onStarted === void 0 || _this$props$onStarted.call(_this$props2);\n  }\n  onStopped() {\n    var _this$props$onStopped, _this$props3;\n    (_this$props$onStopped = (_this$props3 = this.props).onStopped) === null || _this$props$onStopped === void 0 || _this$props$onStopped.call(_this$props3);\n  }\n  //#endregion\n\n  onCodeScanned(event) {\n    const codeScanner = this.props.codeScanner;\n    if (codeScanner == null) return;\n    codeScanner.onCodeScanned(event.nativeEvent.codes, event.nativeEvent.frame);\n  }\n\n  //#region Lifecycle\n  setFrameProcessor(frameProcessor) {\n    VisionCameraProxy.setFrameProcessor(this.handle, frameProcessor);\n  }\n  unsetFrameProcessor() {\n    VisionCameraProxy.removeFrameProcessor(this.handle);\n  }\n  onViewReady() {\n    this.isNativeViewMounted = true;\n    if (this.props.frameProcessor != null) {\n      // user passed a `frameProcessor` but we didn't set it yet because the native view was not mounted yet. set it now.\n      this.setFrameProcessor(this.props.frameProcessor);\n      this.lastFrameProcessor = this.props.frameProcessor;\n    }\n  }\n\n  /** @internal */\n  componentDidUpdate() {\n    if (!this.isNativeViewMounted) return;\n    const frameProcessor = this.props.frameProcessor;\n    if (frameProcessor !== this.lastFrameProcessor) {\n      // frameProcessor argument identity changed. Update native to reflect the change.\n      if (frameProcessor != null) this.setFrameProcessor(frameProcessor);else this.unsetFrameProcessor();\n      this.lastFrameProcessor = frameProcessor;\n    }\n  }\n  //#endregion\n\n  /** @internal */\n  render() {\n    // We remove the big `device` object from the props because we only need to pass `cameraId` to native.\n    const {\n      device,\n      frameProcessor,\n      codeScanner,\n      ...props\n    } = this.props;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (device == null) {\n      throw new Error('Camera: `device` is null! Select a valid Camera device. See: https://mrousavy.com/react-native-vision-camera/docs/guides/devices');\n    }\n    const shouldEnableBufferCompression = props.video === true && frameProcessor == null;\n    const torch = this.state.isRecordingWithFlash ? 'on' : props.torch;\n    return /*#__PURE__*/React.createElement(NativeCameraView, _extends({}, props, {\n      cameraId: device.id,\n      ref: this.ref,\n      torch: torch,\n      onViewReady: this.onViewReady,\n      onInitialized: this.onInitialized,\n      onCodeScanned: this.onCodeScanned,\n      onStarted: this.onStarted,\n      onStopped: this.onStopped,\n      onError: this.onError,\n      codeScannerOptions: codeScanner,\n      enableFrameProcessor: frameProcessor != null,\n      enableBufferCompression: props.enableBufferCompression ?? shouldEnableBufferCompression\n    }));\n  }\n}\n//#endregion\n\n// requireNativeComponent automatically resolves 'CameraView' to 'CameraViewManager'\nconst NativeCameraView = requireNativeComponent('CameraView',\n// @ts-expect-error because the type declarations are kinda wrong, no?\nCamera);","map":{"version":3,"names":["React","requireNativeComponent","findNodeHandle","CameraRuntimeError","tryParseNativeCameraError","isErrorWithCause","CameraModule","VisionCameraProxy","CameraDevices","Camera","PureComponent","displayName","isNativeViewMounted","constructor","props","onViewReady","bind","onInitialized","onStarted","onStopped","onError","onCodeScanned","ref","createRef","lastFrameProcessor","undefined","state","isRecordingWithFlash","handle","nodeHandle","current","takePhoto","options","e","getBitRateMultiplier","bitRate","startRecording","onRecordingError","onRecordingFinished","videoBitRate","passThruOptions","flash","setState","nativeOptions","videoBitRateOverride","videoBitRateMultiplier","onRecordCallback","video","error","pauseRecording","resumeRecording","stopRecording","focus","point","getAvailableCameraDevices","addCameraDevicesChangedListener","listener","getCameraPermissionStatus","getMicrophonePermissionStatus","requestCameraPermission","requestMicrophonePermission","event","nativeEvent","cause","cameraError","code","message","console","_this$props$onInitial","_this$props","call","_this$props$onStarted","_this$props2","_this$props$onStopped","_this$props3","codeScanner","codes","frame","setFrameProcessor","frameProcessor","unsetFrameProcessor","removeFrameProcessor","componentDidUpdate","render","device","Error","shouldEnableBufferCompression","torch","createElement","NativeCameraView","_extends","cameraId","id","codeScannerOptions","enableFrameProcessor","enableBufferCompression"],"sources":["C:\\Users\\Samue\\OneDrive\\Documents\\University\\Year 3\\Computing Project\\Code\\RevisionWebApp\\re-vision\\node_modules\\react-native-vision-camera\\src\\Camera.tsx"],"sourcesContent":["import React from 'react'\nimport { requireNativeComponent, NativeSyntheticEvent, findNodeHandle, NativeMethods } from 'react-native'\nimport type { CameraDevice } from './CameraDevice'\nimport type { ErrorWithCause } from './CameraError'\nimport { CameraCaptureError, CameraRuntimeError, tryParseNativeCameraError, isErrorWithCause } from './CameraError'\nimport type { CameraProps, FrameProcessor } from './CameraProps'\nimport { CameraModule } from './NativeCameraModule'\nimport type { PhotoFile, TakePhotoOptions } from './PhotoFile'\nimport type { Point } from './Point'\nimport type { RecordVideoOptions, VideoFile } from './VideoFile'\nimport { VisionCameraProxy } from './FrameProcessorPlugins'\nimport { CameraDevices } from './CameraDevices'\nimport type { EmitterSubscription } from 'react-native'\nimport type { Code, CodeScanner, CodeScannerFrame } from './CodeScanner'\n\n//#region Types\nexport type CameraPermissionStatus = 'granted' | 'not-determined' | 'denied' | 'restricted'\nexport type CameraPermissionRequestResult = 'granted' | 'denied'\n\ninterface OnCodeScannedEvent {\n  codes: Code[]\n  frame: CodeScannerFrame\n}\ninterface OnErrorEvent {\n  code: string\n  message: string\n  cause?: ErrorWithCause\n}\ntype NativeCameraViewProps = Omit<CameraProps, 'device' | 'onInitialized' | 'onError' | 'frameProcessor' | 'codeScanner'> & {\n  cameraId: string\n  enableFrameProcessor: boolean\n  codeScannerOptions?: Omit<CodeScanner, 'onCodeScanned'>\n  onInitialized?: (event: NativeSyntheticEvent<void>) => void\n  onError?: (event: NativeSyntheticEvent<OnErrorEvent>) => void\n  onCodeScanned?: (event: NativeSyntheticEvent<OnCodeScannedEvent>) => void\n  onStarted?: (event: NativeSyntheticEvent<void>) => void\n  onStopped?: (event: NativeSyntheticEvent<void>) => void\n  onViewReady: () => void\n}\ntype NativeRecordVideoOptions = Omit<RecordVideoOptions, 'onRecordingError' | 'onRecordingFinished' | 'videoBitRate'> & {\n  videoBitRateOverride?: number\n  videoBitRateMultiplier?: number\n}\ntype RefType = React.Component<NativeCameraViewProps> & Readonly<NativeMethods>\ninterface CameraState {\n  isRecordingWithFlash: boolean\n}\n//#endregion\n\n//#region Camera Component\n/**\n * ### A powerful `<Camera>` component.\n *\n * Read the [VisionCamera documentation](https://react-native-vision-camera.com/) for more information.\n *\n * The `<Camera>` component's most important properties are:\n *\n * * {@linkcode CameraProps.device | device}: Specifies the {@linkcode CameraDevice} to use. Get a {@linkcode CameraDevice} by using the {@linkcode useCameraDevice | useCameraDevice(..)} hook, or manually by using the {@linkcode CameraDevices.getAvailableCameraDevices CameraDevices.getAvailableCameraDevices()} function.\n * * {@linkcode CameraProps.isActive | isActive}: A boolean value that specifies whether the Camera should actively stream video frames or not. This can be compared to a Video component, where `isActive` specifies whether the video is paused or not. If you fully unmount the `<Camera>` component instead of using `isActive={false}`, the Camera will take a bit longer to start again.\n *\n * @example\n * ```tsx\n * function App() {\n *   const device = useCameraDevice('back')\n *\n *   if (device == null) return <NoCameraErrorView />\n *   return (\n *     <Camera\n *       style={StyleSheet.absoluteFill}\n *       device={device}\n *       isActive={true}\n *     />\n *   )\n * }\n * ```\n *\n * @component\n */\nexport class Camera extends React.PureComponent<CameraProps, CameraState> {\n  /** @internal */\n  static displayName = 'Camera'\n  /** @internal */\n  displayName = Camera.displayName\n  private lastFrameProcessor: FrameProcessor | undefined\n  private isNativeViewMounted = false\n\n  private readonly ref: React.RefObject<RefType>\n\n  /** @internal */\n  constructor(props: CameraProps) {\n    super(props)\n    this.onViewReady = this.onViewReady.bind(this)\n    this.onInitialized = this.onInitialized.bind(this)\n    this.onStarted = this.onStarted.bind(this)\n    this.onStopped = this.onStopped.bind(this)\n    this.onError = this.onError.bind(this)\n    this.onCodeScanned = this.onCodeScanned.bind(this)\n    this.ref = React.createRef<RefType>()\n    this.lastFrameProcessor = undefined\n    this.state = {\n      isRecordingWithFlash: false,\n    }\n  }\n\n  private get handle(): number {\n    const nodeHandle = findNodeHandle(this.ref.current)\n    if (nodeHandle == null || nodeHandle === -1) {\n      throw new CameraRuntimeError(\n        'system/view-not-found',\n        \"Could not get the Camera's native view tag! Does the Camera View exist in the native view-tree?\",\n      )\n    }\n\n    return nodeHandle\n  }\n\n  //#region View-specific functions (UIViewManager)\n  /**\n   * Take a single photo and write it's content to a temporary file.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while capturing the photo. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * const photo = await camera.current.takePhoto({\n   *   qualityPrioritization: 'quality',\n   *   flash: 'on',\n   *   enableAutoRedEyeReduction: true\n   * })\n   * ```\n   */\n  public async takePhoto(options?: TakePhotoOptions): Promise<PhotoFile> {\n    try {\n      return await CameraModule.takePhoto(this.handle, options ?? {})\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n\n  private getBitRateMultiplier(bitRate: RecordVideoOptions['videoBitRate']): number {\n    if (typeof bitRate === 'number' || bitRate == null) return 1\n    switch (bitRate) {\n      case 'extra-low':\n        return 0.6\n      case 'low':\n        return 0.8\n      case 'normal':\n        return 1\n      case 'high':\n        return 1.2\n      case 'extra-high':\n        return 1.4\n    }\n  }\n\n  /**\n   * Start a new video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while starting the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * camera.current.startRecording({\n   *   onRecordingFinished: (video) => console.log(video),\n   *   onRecordingError: (error) => console.error(error),\n   * })\n   * setTimeout(() => {\n   *   camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  public startRecording(options: RecordVideoOptions): void {\n    const { onRecordingError, onRecordingFinished, videoBitRate, ...passThruOptions } = options\n    if (typeof onRecordingError !== 'function' || typeof onRecordingFinished !== 'function')\n      throw new CameraRuntimeError('parameter/invalid-parameter', 'The onRecordingError or onRecordingFinished functions were not set!')\n\n    if (options.flash === 'on') {\n      // Enable torch for video recording\n      this.setState({\n        isRecordingWithFlash: true,\n      })\n    }\n\n    const nativeOptions: NativeRecordVideoOptions = passThruOptions\n    if (typeof videoBitRate === 'number') {\n      // If the user passed an absolute number as a bit-rate, we just use this as a full override.\n      nativeOptions.videoBitRateOverride = videoBitRate\n    } else if (typeof videoBitRate === 'string' && videoBitRate !== 'normal') {\n      // If the user passed 'low'/'normal'/'high', we need to apply this as a multiplier to the native bitrate instead of absolutely setting it\n      nativeOptions.videoBitRateMultiplier = this.getBitRateMultiplier(videoBitRate)\n    }\n\n    const onRecordCallback = (video?: VideoFile, error?: CameraCaptureError): void => {\n      if (this.state.isRecordingWithFlash) {\n        // disable torch again if it was enabled\n        this.setState({\n          isRecordingWithFlash: false,\n        })\n      }\n\n      if (error != null) return onRecordingError(error)\n      if (video != null) return onRecordingFinished(video)\n    }\n    try {\n      // TODO: Use TurboModules to make this awaitable.\n      CameraModule.startRecording(this.handle, nativeOptions, onRecordCallback)\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n\n  /**\n   * Pauses the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while pausing the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  public async pauseRecording(): Promise<void> {\n    try {\n      return await CameraModule.pauseRecording(this.handle)\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n\n  /**\n   * Resumes a currently paused video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while resuming the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * // Start\n   * await camera.current.startRecording()\n   * await timeout(1000)\n   * // Pause\n   * await camera.current.pauseRecording()\n   * await timeout(500)\n   * // Resume\n   * await camera.current.resumeRecording()\n   * await timeout(2000)\n   * // Stop\n   * const video = await camera.current.stopRecording()\n   * ```\n   */\n  public async resumeRecording(): Promise<void> {\n    try {\n      return await CameraModule.resumeRecording(this.handle)\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n\n  /**\n   * Stop the current video recording.\n   *\n   * @throws {@linkcode CameraCaptureError} When any kind of error occured while stopping the video recording. Use the {@linkcode CameraCaptureError.code | code} property to get the actual error\n   *\n   * @example\n   * ```ts\n   * await camera.current.startRecording()\n   * setTimeout(async () => {\n   *  const video = await camera.current.stopRecording()\n   * }, 5000)\n   * ```\n   */\n  public async stopRecording(): Promise<void> {\n    try {\n      return await CameraModule.stopRecording(this.handle)\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n\n  /**\n   * Focus the camera to a specific point in the coordinate system.\n   * @param {Point} point The point to focus to. This should be relative\n   * to the Camera view's coordinate system and is expressed in points.\n   *  * `(0, 0)` means **top left**.\n   *  * `(CameraView.width, CameraView.height)` means **bottom right**.\n   *\n   * Make sure the value doesn't exceed the CameraView's dimensions.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while focussing. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   * @example\n   * ```ts\n   * await camera.current.focus({\n   *   x: tapEvent.x,\n   *   y: tapEvent.y\n   * })\n   * ```\n   */\n  public async focus(point: Point): Promise<void> {\n    try {\n      return await CameraModule.focus(this.handle, point)\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n  //#endregion\n\n  //#region Static Functions (NativeModule)\n  /**\n   * Get a list of all available camera devices on the current phone.\n   *\n   * If you use Hooks, use the `useCameraDevices(..)` hook instead.\n   *\n   * * For Camera Devices attached to the phone, it is safe to assume that this will never change.\n   * * For external Camera Devices (USB cameras, Mac continuity cameras, etc.) the available Camera Devices could change over time when the external Camera device gets plugged in or plugged out, so use {@link addCameraDevicesChangedListener | addCameraDevicesChangedListener(...)} to listen for such changes.\n   *\n   * @example\n   * ```ts\n   * const devices = Camera.getAvailableCameraDevices()\n   * const backCameras = devices.filter((d) => d.position === \"back\")\n   * const frontCameras = devices.filter((d) => d.position === \"front\")\n   * ```\n   */\n  public static getAvailableCameraDevices(): CameraDevice[] {\n    return CameraDevices.getAvailableCameraDevices()\n  }\n  /**\n   * Adds a listener that gets called everytime the Camera Devices change, for example\n   * when an external Camera Device (USB or continuity Camera) gets plugged in or plugged out.\n   *\n   * If you use Hooks, use the `useCameraDevices()` hook instead.\n   */\n  public static addCameraDevicesChangedListener(listener: (newDevices: CameraDevice[]) => void): EmitterSubscription {\n    return CameraDevices.addCameraDevicesChangedListener(listener)\n  }\n  /**\n   * Gets the current Camera Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the camera.\n   *\n   * To actually prompt the user for camera permission, use {@linkcode Camera.requestCameraPermission | requestCameraPermission()}.\n   */\n  public static getCameraPermissionStatus(): CameraPermissionStatus {\n    return CameraModule.getCameraPermissionStatus()\n  }\n  /**\n   * Gets the current Microphone-Recording Permission Status. Check this before mounting the Camera to ensure\n   * the user has permitted the app to use the microphone.\n   *\n   * To actually prompt the user for microphone permission, use {@linkcode Camera.requestMicrophonePermission | requestMicrophonePermission()}.\n   */\n  public static getMicrophonePermissionStatus(): CameraPermissionStatus {\n    return CameraModule.getMicrophonePermissionStatus()\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new camera permission status.\n   *\n   * If the user has previously blocked the app from using the camera, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async requestCameraPermission(): Promise<CameraPermissionRequestResult> {\n    try {\n      return await CameraModule.requestCameraPermission()\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n  /**\n   * Shows a \"request permission\" alert to the user, and resolves with the new microphone permission status.\n   *\n   * If the user has previously blocked the app from using the microphone, the alert will not be shown\n   * and `\"denied\"` will be returned.\n   *\n   * @throws {@linkcode CameraRuntimeError} When any kind of error occured while requesting permission. Use the {@linkcode CameraRuntimeError.code | code} property to get the actual error\n   */\n  public static async requestMicrophonePermission(): Promise<CameraPermissionRequestResult> {\n    try {\n      return await CameraModule.requestMicrophonePermission()\n    } catch (e) {\n      throw tryParseNativeCameraError(e)\n    }\n  }\n  //#endregion\n\n  //#region Events (Wrapped to maintain reference equality)\n  private onError(event: NativeSyntheticEvent<OnErrorEvent>): void {\n    const error = event.nativeEvent\n    const cause = isErrorWithCause(error.cause) ? error.cause : undefined\n    // @ts-expect-error We're casting from unknown bridge types to TS unions, I expect it to hopefully work\n    const cameraError = new CameraRuntimeError(error.code, error.message, cause)\n\n    if (this.props.onError != null) {\n      this.props.onError(cameraError)\n    } else {\n      // User didn't pass an `onError` handler, so just log it to console\n      console.error(`Camera.onError(${cameraError.code}): ${cameraError.message}`, cameraError)\n    }\n  }\n\n  private onInitialized(): void {\n    this.props.onInitialized?.()\n  }\n\n  private onStarted(): void {\n    this.props.onStarted?.()\n  }\n\n  private onStopped(): void {\n    this.props.onStopped?.()\n  }\n  //#endregion\n\n  private onCodeScanned(event: NativeSyntheticEvent<OnCodeScannedEvent>): void {\n    const codeScanner = this.props.codeScanner\n    if (codeScanner == null) return\n\n    codeScanner.onCodeScanned(event.nativeEvent.codes, event.nativeEvent.frame)\n  }\n\n  //#region Lifecycle\n  private setFrameProcessor(frameProcessor: FrameProcessor): void {\n    VisionCameraProxy.setFrameProcessor(this.handle, frameProcessor)\n  }\n\n  private unsetFrameProcessor(): void {\n    VisionCameraProxy.removeFrameProcessor(this.handle)\n  }\n\n  private onViewReady(): void {\n    this.isNativeViewMounted = true\n    if (this.props.frameProcessor != null) {\n      // user passed a `frameProcessor` but we didn't set it yet because the native view was not mounted yet. set it now.\n      this.setFrameProcessor(this.props.frameProcessor)\n      this.lastFrameProcessor = this.props.frameProcessor\n    }\n  }\n\n  /** @internal */\n  componentDidUpdate(): void {\n    if (!this.isNativeViewMounted) return\n    const frameProcessor = this.props.frameProcessor\n    if (frameProcessor !== this.lastFrameProcessor) {\n      // frameProcessor argument identity changed. Update native to reflect the change.\n      if (frameProcessor != null) this.setFrameProcessor(frameProcessor)\n      else this.unsetFrameProcessor()\n\n      this.lastFrameProcessor = frameProcessor\n    }\n  }\n  //#endregion\n\n  /** @internal */\n  public render(): React.ReactNode {\n    // We remove the big `device` object from the props because we only need to pass `cameraId` to native.\n    const { device, frameProcessor, codeScanner, ...props } = this.props\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (device == null) {\n      throw new Error(\n        'Camera: `device` is null! Select a valid Camera device. See: https://mrousavy.com/react-native-vision-camera/docs/guides/devices',\n      )\n    }\n\n    const shouldEnableBufferCompression = props.video === true && frameProcessor == null\n    const torch = this.state.isRecordingWithFlash ? 'on' : props.torch\n\n    return (\n      <NativeCameraView\n        {...props}\n        cameraId={device.id}\n        ref={this.ref}\n        torch={torch}\n        onViewReady={this.onViewReady}\n        onInitialized={this.onInitialized}\n        onCodeScanned={this.onCodeScanned}\n        onStarted={this.onStarted}\n        onStopped={this.onStopped}\n        onError={this.onError}\n        codeScannerOptions={codeScanner}\n        enableFrameProcessor={frameProcessor != null}\n        enableBufferCompression={props.enableBufferCompression ?? shouldEnableBufferCompression}\n      />\n    )\n  }\n}\n//#endregion\n\n// requireNativeComponent automatically resolves 'CameraView' to 'CameraViewManager'\nconst NativeCameraView = requireNativeComponent<NativeCameraViewProps>(\n  'CameraView',\n  // @ts-expect-error because the type declarations are kinda wrong, no?\n  Camera,\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}